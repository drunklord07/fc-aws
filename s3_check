#!/usr/bin/env bash
# S3 Public WRITE ACL Audit (parallel + progress bar; AWS CLI only)
# Rule: NOT_COMPLIANT if bucket ACL grants AllUsers -> WRITE; else COMPLIANT.
# Output: table of ALL buckets + summary. Skips include a clear reason.
# Log file: ./s3_acl_public_write_audit.log

export AWS_PAGER=""

# ---- Colors & helpers ----
BOLD=$'\033[1m'; DIM=$'\033[2m'; RESET=$'\033[0m'
GREEN=$'\033[32m'; RED=$'\033[31m'; YELLOW=$'\033[33m'

hr() {
  cols=$(tput cols 2>/dev/null || echo 80)
  printf '%*s\n' "$cols" '' | tr ' ' '-'
}
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1"; exit 1; }; }
need aws
need awk

# ---- Workers (override with: JOBS=24 ./s3_acl_public_write_audit.sh) ----
JOBS="${JOBS:-16}"
case "$JOBS" in (''|*[!0-9]*) JOBS=16;; esac
[ "$JOBS" -lt 1 ] && JOBS=1

ACCOUNT="$(aws sts get-caller-identity --query 'Account' --output text 2>/dev/null || echo UNKNOWN)"
ARN="$(aws sts get-caller-identity --query 'Arn' --output text 2>/dev/null || echo UNKNOWN)"
LOG_FILE="$PWD/s3_acl_public_write_audit.log"
: > "$LOG_FILE"

# ---- Temp files ----
TMP_LIST="$(mktemp -t s3_buckets.XXXXXX)"
TMP_RES="$(mktemp -t s3_results.XXXXXX)"
TMP_TAB="$(mktemp -t s3_table.XXXXXX)"
trap 'rm -f "$TMP_LIST" "$TMP_RES" "$TMP_TAB" 2>/dev/null || true' EXIT

# ---- Collect buckets (global) ----
if ! aws s3api list-buckets --query 'Buckets[].Name' --output text 2>/dev/null > "$TMP_LIST"; then
  echo "${YELLOW}No access to list buckets or none found.${RESET}"
  hr
  echo "${BOLD}Summary${RESET}"
  printf "Total buckets   : 0\nChecked         : 0\n  ${GREEN}Compliant${RESET}      : 0 (0.0%%)\n  ${RED}Not compliant${RESET}   : 0 (0.0%%)\nSkipped         : 0\n"
  hr
  echo "${DIM}Rule: NOT_COMPLIANT if ACL grants AllUsers -> WRITE; otherwise COMPLIANT.${RESET}"
  exit 0
fi
tr '\t' '\n' < "$TMP_LIST" | sed '/^$/d' > "${TMP_LIST}.clean"
mv "${TMP_LIST}.clean" "$TMP_LIST"

TOTAL="$(wc -l < "$TMP_LIST" 2>/dev/null | tr -d ' ')"
[ -z "$TOTAL" ] && TOTAL=0

echo
echo "${BOLD}S3 Public WRITE ACL Audit${RESET}"
echo "Account: ${BOLD}$ACCOUNT${RESET}"
echo "Caller : ${DIM}$ARN${RESET}"
hr

if [ "$TOTAL" -eq 0 ]; then
  echo "${YELLOW}No S3 buckets found.${RESET}"
  hr
  echo "${BOLD}Summary${RESET}"
  printf "Total buckets   : 0\nChecked         : 0\n  ${GREEN}Compliant${RESET}      : 0 (0.0%%)\n  ${RED}Not compliant${RESET}   : 0 (0.0%%)\nSkipped         : 0\n"
  hr
  echo "${DIM}Rule: NOT_COMPLIANT if ACL grants AllUsers -> WRITE; otherwise COMPLIANT.${RESET}"
  exit 0
fi

# ---- Progress bar (same style as your EC2 script) ----
draw_progress() {
  done_amt="$1"; total_amt="$2"
  cols=$(tput cols 2>/dev/null || echo 80)
  barw=$(( cols - 36 )); [ "$barw" -lt 10 ] && barw=10
  if [ "$total_amt" -gt 0 ]; then filled=$(( done_amt * barw / total_amt )); else filled=0; fi
  [ "$filled" -lt 0 ] && filled=0
  [ "$filled" -gt "$barw" ] && filled="$barw"
  empty=$(( barw - filled ))
  if [ "$total_amt" -gt 0 ]; then pct=$(( done_amt * 100 / total_amt )); else pct=0; fi
  printf "\rProcessing: ["
  i=0; while [ $i -lt $filled ]; do printf "#"; i=$((i+1)); done
  i=0; while [ $i -lt $empty  ]; do printf "-"; i=$((i+1)); done
  printf "] %3d%% (%d/%d)" "$pct" "$done_amt" "$total_amt"
}
progress_loop() {
  res_file="$1"; total_amt="$2"; done_prev=-1; done_now=0
  while :; do
    done_now="$(wc -l < "$res_file" 2>/dev/null | tr -d ' ')"
    [ -z "$done_now" ] && done_now=0
    if [ "$done_now" -ne "$done_prev" ]; then
      draw_progress "$done_now" "$total_amt"
      done_prev="$done_now"
    fi
    [ "$done_now" -ge "$total_amt" ] && break
    sleep 0.2
  done
  echo
}

# ---- Semaphore for parallelism (Bash 3 compatible) ----
SEM="$(mktemp -u)"; mkfifo "$SEM" || { echo "mkfifo failed"; exit 1; }
exec 3<>"$SEM"; rm -f "$SEM"
k=0; while [ $k -lt "$JOBS" ]; do echo >&3; k=$((k+1)); done

# ---- Worker: check one bucket ----
# Output per line (tab-separated):
# STATUS  BUCKET  ALLUSERS_PERMISSIONS  REASON
# STATUS âˆˆ {COMPLIANT, NOT_COMPLIANT, SKIPPED}
check_one() {
  bkt="$1"

  # Query AllUsers grants; capture stdout+stderr
  raw="$(aws s3api get-bucket-acl \
      --bucket "$bkt" \
      --query 'Grants[?Grantee.URI==`http://acs.amazonaws.com/groups/global/AllUsers`].Permission' \
      --output text 2>&1)"
  rc=$?

  if [ $rc -ne 0 ]; then
    # Normalize a clear single-line reason
    reason="$(printf '%s\n' "$raw" | head -n1 | tr '\t' ' ' | tr -d '\r')"
    echo "$bkt | ERROR | $reason" >> "$LOG_FILE"

    # Simplify common AWS errors
    shrt="$reason"
    echo "$reason" | grep -qi 'AccessDenied'   && shrt='AccessDenied on GetBucketAcl'
    echo "$reason" | grep -qi 'NoSuchBucket'   && shrt='NoSuchBucket'
    echo "$reason" | grep -qi 'ExpiredToken'   && shrt='ExpiredToken'
    echo "$reason" | grep -qi 'SignatureDoesNotMatch' && shrt='BadSignature'
    echo "$reason" | grep -qi 'AllAccessDisabled' && shrt='AllAccessDisabled'

    printf "SKIPPED\t%s\t\t%s\n" "$bkt" "$shrt" >> "$TMP_RES"
    return
  fi

  # Success path
  perms="$(printf '%s' "$raw" | tr '\t' ' ' | sed 's/[[:space:]]\+/ /g; s/^ //; s/ $//')"
  if printf '%s\n' "$perms" | grep -qw WRITE; then
    printf "NOT_COMPLIANT\t%s\t%s\tAllUsers has WRITE\n" "$bkt" "$perms" >> "$TMP_RES"
  else
    if [ -z "$perms" ] || [ "$perms" = "None" ]; then
      printf "COMPLIANT\t%s\t\tNo AllUsers grant\n" "$bkt" >> "$TMP_RES"
    else
      printf "COMPLIANT\t%s\t%s\tAllUsers without WRITE\n" "$bkt" "$perms" >> "$TMP_RES"
    fi
  fi
}

# ---- Start progress and workers ----
progress_loop "$TMP_RES" "$TOTAL" & PROG_PID=$!

while IFS= read -r bucket; do
  read -r -u 3
  {
    check_one "$bucket"
    echo >&3
  } &
done < "$TMP_LIST"

wait
wait "$PROG_PID" 2>/dev/null || true

# ---- Build table ----
{
  printf "BUCKET\tSTATUS\tALLUSERS_PERMISSIONS\tREASON\n"
  awk -F'\t' '{printf "%s\t%s\t%s\t%s\n",$2,$1,$3,$4}' "$TMP_RES"
} > "$TMP_TAB"

echo
echo "${BOLD}Bucket Compliance Table${RESET}"
hr
if command -v column >/dev/null 2>&1; then
  column -t -s $'\t' "$TMP_TAB"
else
  cat "$TMP_TAB"
fi

# ---- Aggregate counts ----
COMPLIANT_COUNT="$(awk -F'\t' '$1=="COMPLIANT"{c++} END{print c+0}' "$TMP_RES")"
NOT_COUNT="$(awk -F'\t'      '$1=="NOT_COMPLIANT"{c++} END{print c+0}' "$TMP_RES")"
SKIPPED_COUNT="$(awk -F'\t'  '$1=="SKIPPED"{c++} END{print c+0}' "$TMP_RES")"
CHECKED=$(( COMPLIANT_COUNT + NOT_COUNT ))
pct() { awk -v n="$1" -v d="$2" 'BEGIN{ if (d==0) printf "0.0"; else printf "%.1f", (n*100.0)/d }'; }

hr
echo "${BOLD}Summary${RESET}"
printf "Total buckets   : %s\n" "$TOTAL"
printf "Checked         : %s\n" "$CHECKED"
printf "  ${GREEN}Compliant${RESET}      : %s (%s%%)\n" "$COMPLIANT_COUNT" "$(pct "$COMPLIANT_COUNT" "$CHECKED")"
printf "  ${RED}Not compliant${RESET}   : %s (%s%%)\n" "$NOT_COUNT" "$(pct "$NOT_COUNT" "$CHECKED")"
printf "Skipped         : %s\n" "$SKIPPED_COUNT"
hr
echo "${DIM}Rule: NOT_COMPLIANT if ACL grants AllUsers -> WRITE; otherwise COMPLIANT.${RESET}"

# Optional: quick lists
if [ "$NOT_COUNT" -gt 0 ]; then
  echo
  echo "${RED}Non-compliant buckets (public WRITE):${RESET}"
  awk -F'\t' '$1=="NOT_COMPLIANT"{print " - " $2}' "$TMP_RES" | sort
fi

if [ "$SKIPPED_COUNT" -gt 0 ]; then
  echo
  echo "${YELLOW}Skipped (with reason):${RESET}"
  awk -F'\t' '$1=="SKIPPED"{printf " - %s: %s\n",$2,($4==""?"Unknown":$4)}' "$TMP_RES"
  echo
  echo "${DIM}Full error text saved to:${RESET} $LOG_FILE"
fi
