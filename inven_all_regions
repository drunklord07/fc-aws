#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Part 1 — Run Prowler Quick Inventory per-region with per-region outputs and a reasoned skip log.

Fixes:
- Auto-detects region flag (--region vs --filter-region) from your local Prowler help.
- More accurate error reason parsing (all lowercase match).
- Passes profile to Prowler with -p as well as AWS_PROFILE env (if provided).

Outputs:
  <output>/
    <region>/quickinv_<region>_<stamp>.csv|json + run.log
    logs/<region>.log
    reports/summary_<stamp>.csv
"""

import argparse
import csv
import os
import shlex
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Tuple

PROWLER_BIN_DEFAULT = "prowler"

# Conservative, commercial partitions list (fallback if CLI listing fails)
FALLBACK_REGIONS = [
    "af-south-1",
    "ap-east-1",
    "ap-south-1", "ap-south-2",
    "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ap-southeast-5", "ap-southeast-6", "ap-southeast-7",
    "ap-northeast-1", "ap-northeast-2", "ap-northeast-3",
    "ca-central-1", "ca-west-1",
    "eu-central-1", "eu-central-2",
    "eu-west-1", "eu-west-2", "eu-west-3",
    "eu-north-1",
    "eu-south-1", "eu-south-2",
    "il-central-1",
    "me-south-1", "me-central-1",
    "sa-east-1",
    "us-east-1", "us-east-2", "us-west-1", "us-west-2",
]

def parse_args():
    p = argparse.ArgumentParser("Run Prowler quick-inventory per region with per-region outputs and logging.")
    p.add_argument("--profile", default="", help="AWS profile to use (sets AWS_PROFILE and passes -p to Prowler).")
    p.add_argument("--output", default="./quickinv_by_region", help="Base output folder.")
    p.add_argument("--regions-file", default="", help="Optional file with one region per line (or comma/space separated).")
    p.add_argument("--timeout", type=int, default=0, help="Per-region timeout in seconds (0 = no timeout).")
    p.add_argument("--prefix", default="quickinv", help="Filename prefix for Prowler outputs.")
    p.add_argument("--prowler-bin", default=PROWLER_BIN_DEFAULT, help="Prowler executable name/path.")
    return p.parse_args()

def ts() -> str:
    return datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")

def ensure_dirs(base: Path) -> Dict[str, Path]:
    d = {"root": base, "logs": base / "logs", "reports": base / "reports"}
    for v in d.values(): v.mkdir(parents=True, exist_ok=True)
    return d

def run_cmd(cmd: List[str], env: dict, timeout: int) -> Tuple[int, str]:
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, env=env)
    out_lines = []
    start = time.time()
    while True:
        line = proc.stdout.readline()
        if line:
            out_lines.append(line)
        if proc.poll() is not None:
            break
        if timeout and (time.time() - start) > timeout:
            proc.kill()
            out_lines.append(f"[ERROR] Timed out after {timeout}s\n")
            return 124, "".join(out_lines)
    return proc.returncode, "".join(out_lines)

def get_regions_from_cli(env: dict) -> List[str]:
    try:
        cmd = ["aws", "ec2", "describe-regions", "--all-regions", "--query", "Regions[].RegionName", "--output", "text"]
        rc, out = run_cmd(cmd, env, timeout=30)
        return out.split() if rc == 0 and out.strip() else []
    except Exception:
        return []

def read_regions_file(path: Path) -> List[str]:
    text = path.read_text(encoding="utf-8", errors="ignore")
    raw = [r.strip() for r in text.replace(",", " ").split()]
    return [r for r in raw if r]

def newest_file(folder: Path, prefix: str, ext: str) -> Optional[Path]:
    candidates = list(folder.glob(f"**/{prefix}*.{ext}"))
    return max(candidates, key=lambda p: p.stat().st_mtime) if candidates else None

def parse_reason(text: str, exit_code: int) -> str:
    low = text.lower()
    patterns = {
        "optinrequired": "Region not enabled (OptInRequired)",
        "authfailure": "AuthFailure (bad/missing creds or region policy)",
        "accessdenied": "AccessDenied (insufficient permissions)",
        "signaturedoesnotmatch": "SignatureDoesNotMatch (clock skew or wrong keys)",
        "expiredtoken": "ExpiredToken",
        "invalidclienttokenid": "InvalidClientTokenId",
        "noregion": "NoRegion (set AWS_DEFAULT_REGION or pass region)",
        "could not connect to the endpoint": "EndpointConnectionError",
        "throttl": "Throttling",
        "unsupported": "Unsupported region/service",
        "unknown endpoint": "UnknownEndpoint (bad region code?)",
        "assumerole": "AssumeRole failure",
        "token": "STS/Token issue",
        "profile": "Profile issue",
        "no such option": "CLI option not supported",
        "unknown option": "CLI option not supported",
        "invalid option": "CLI option not supported",
    }
    for k, v in patterns.items():
        if k in low:
            return v
    if exit_code == 124:
        return "Timed out"
    if exit_code != 0:
        return "Non-zero exit (see log)"
    return "OK"

def detect_region_flag(prowler_bin: str, env: dict) -> str:
    """Detect whether Prowler supports --region or --filter-region for quick-inventory."""
    rc, out = run_cmd([prowler_bin, "aws", "--quick-inventory", "--help"], env, timeout=20)
    low = (out or "").lower()
    # Prefer --region if present (matches your manual usage), else fall back to --filter-region
    if "--region" in low:
        return "--region"
    if "--filter-region" in low:
        return "--filter-region"
    # Fallback to --region (works on newer builds)
    return "--region"

def run_prowler_region(prowler_bin: str, region_flag: str, region: str, out_dir: Path,
                       prefix: str, env: dict, timeout: int, profile: str) -> Tuple[List[str], int, str]:
    # Build base command exactly like you run it, with per-region outputs
    cmd = [prowler_bin, "aws", "--quick-inventory", region_flag, region, "-M", "csv,json", "-o", str(out_dir), "-F", prefix]
    # If user passed --profile, set -p as well (and env has AWS_PROFILE)
    if profile:
        cmd.extend(["-p", profile])
    rc, out = run_cmd(cmd, env, timeout=timeout)
    # If the chosen flag isn’t supported, auto-retry with the other one
    if rc != 0 and ("no such option" in out.lower() or "unknown option" in out.lower() or "invalid option" in out.lower()):
        alt_flag = "--filter-region" if region_flag == "--region" else "--region"
        cmd = [prowler_bin, "aws", "--quick-inventory", alt_flag, region, "-M", "csv,json", "-o", str(out_dir), "-F", prefix]
        if profile:
            cmd.extend(["-p", profile])
        rc, out = run_cmd(cmd, env, timeout=timeout)
    return cmd, rc, out

def main():
    args = parse_args()

    # Verify Prowler is callable
    rc, out = run_cmd([args.prowler_bin, "--version"], env=os.environ.copy(), timeout=15)
    if rc != 0:
        print(f"[ERROR] Cannot run '{args.prowler_bin} --version'. Output:\n{out}")
        sys.exit(1)

    # Env (don’t set AWS_PROFILE unless provided)
    env = os.environ.copy()
    if args.profile:
        env["AWS_PROFILE"] = args.profile

    # Folders
    base = Path(args.output).resolve()
    dirs = ensure_dirs(base)
    stamp = ts()

    # Regions to run
    if args.regions_file:
        path = Path(args.regions_file).expanduser().resolve()
        if not path.exists():
            print(f"[ERROR] --regions-file not found: {path}")
            sys.exit(1)
        regions = read_regions_file(path)
    else:
        regions = get_regions_from_cli(env) or FALLBACK_REGIONS
        if regions == FALLBACK_REGIONS:
            print("[WARN] Could not enumerate regions via AWS CLI. Using fallback list.")

    # Detect correct region flag once
    region_flag = detect_region_flag(args.prowler_bin, env)
    print(f"[INFO] Using region flag: {region_flag}")

    summary_rows = []
    for region in regions:
        region_out_dir = base / region
        region_out_dir.mkdir(parents=True, exist_ok=True)
        log_path = dirs["logs"] / f"{region}.log"
        prefix = f"{args.prefix}_{region}_{stamp}"

        start = time.time()
        cmd, rc, out = run_prowler_region(args.prowler_bin, region_flag, region, region_out_dir, prefix, env, args.timeout, args.profile)
        duration = round(time.time() - start, 1)

        # Write per-region log (command + output)
        log_path.write_text(" ".join(shlex.quote(c) for c in cmd) + "\n\n" + out, encoding="utf-8", errors="ignore")

        reason = parse_reason(out, rc)
        status = "SUCCESS" if rc == 0 else "FAILED"

        csv_file = newest_file(region_out_dir, prefix, "csv")
        json_file = newest_file(region_out_dir, prefix, "json")

        summary_rows.append({
            "region": region,
            "status": status,
            "exit_code": rc,
            "reason": reason,
            "csv_path": str(csv_file or ""),
            "json_path": str(json_file or ""),
            "log_path": str(log_path),
            "duration_sec": duration
        })
        print(f"[{status}] {region} ({duration}s) — {reason}")

    # Summary CSV
    summary_csv = (dirs["reports"] / f"summary_{stamp}.csv")
    with open(summary_csv, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=["region","status","exit_code","reason","csv_path","json_path","log_path","duration_sec"])
        w.writeheader()
        w.writerows(summary_rows)

    total = len(summary_rows)
    ok = sum(1 for r in summary_rows if r["status"] == "SUCCESS")
    bad = total - ok
    print("\n=== SUMMARY ===")
    print(f" Regions attempted : {total}")
    print(f" SUCCESS          : {ok}")
    print(f" FAILED           : {bad}")
    print(f" Output folder    : {base}")
    print(f" Summary CSV      : {summary_csv}")

if __name__ == "__main__":
    main()
